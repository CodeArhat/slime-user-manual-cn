* 三、使用Slime模式

Slime的所有命令都通过slime-mode提供。它是一个与Emacs的lisp-mode配合使用的minor-mode。本章描述slime-mode及其相关事项。

** 3.1 用户界面须知

要方便地使用Slime，了解一些“全局的”用户界面特性是十分重要的。这一部分描述了最为重要的原则。

*** 3.1.1 临时缓冲区

某些Slime命令会创建临时缓冲区来显示结果。虽然这些缓冲区有它们自己的为了特定目的而使用的major-mode，但某些特定的约定是通用的。

可以通过按q键来关闭临时缓冲区。此操作会关闭缓冲区并且回复缓冲区显示之前的窗口配置。临时缓冲区也可以通过一般的命令例如kill-buffer来关闭，这样的话之前的窗口配置就不会被恢复。

按RET键被认为是“做最明显的有用的事情”。例如，在apropos缓冲区此操作会打印出当前光标处的符号的详细描述，而在XREF缓冲区此操作会显示当前光标处的索引的源代码。这样的行为是效仿Emacs的显示相关内容、补全结果等的缓冲区。

含有Lisp符号的临时缓冲区会使用slime-mode来补充它自己的特定的模式。这样就可以使用一般的Slime命令，例如描述符号、查找函数定义等等。

对这些“描述性的”缓冲区的初始聚焦由变量slime-description-autofocus确定。如果它是nil（默认的），这些描述性缓冲区不会自动聚焦，反之则会。

*** 3.1.2 *inferior-lisp*缓冲区

Slime在内部使用comint包来启动Lisp进程。这会产生一些用户可见的结果，有些是好的，另一些则不是。为了避免产生疑惑，理解其交互特性是很有用的。

*inferior-lisp*缓冲区包含有Lisp进程自己的top-level。这个与Lisp的直接连接对错误排查很有用，并且使用inferior-slime-mode可以达到某种程度上的Slime集成。许多人选择加载更好的集成模块SLIME REPL包（见8.2 REPL）而无视*inferior-lisp*缓冲区。（见8.1 加载扩展包 获得更多关于启动REPL的信息。）

*** 3.1.3 多线程

如果Lisp支持多线程，对于每个请求Slime会生成一个新的线程，例如，C-x C-e会创建一个新线程来对表达式求值。但是对于从REPL来的请求则是一个例外：所有在REPL缓冲区里输入的命令都会在一个专用的REPL线程里求值。

多线程和特殊变量会导致一些复杂性。非全局的特殊绑定是在本地线程里的，也就是说，在一个线程里改变一个由let绑定的特殊变量的值不会影响到其它线程里相同名字的变量的值。这增加了改变新线程的打印和读取行为的困难程度。变量swank:*default-worker-thread-bindings*就是为了应付这种情况的：不需要改变一个变量的全局的值，而是增加swank:*default-worker-thread-bindings*的绑定，例如，使用下面的代码，新的线程会默认将浮点值读取为double。

#+BEGIN_SRC emacs-lisp
(push '(*read-default-float-format* . double-float)
      swank:*default-worker-thread-bindings*)
#+END_SRC

*** 3.1.4 键绑定

总体上我们会让我们的键绑定跟Emacs的键绑定配合良好。我们也使用了我们自己的某种不太寻常的约定：当键入一个三次按键的命令时，最后一次按键可以按Control也可以不按。例如，slime-describe-symbol命令的键绑定是C-c C-d d，但是按C-c C-d C-d也是同样的。我们将两种方式都绑定了，因为有些人喜欢三次按键都按着Control键，而有些人则不是。并且有两次按键作为前缀，我们不怕键不够用。

这条规则只有一个例外，希望不要让你中招。我们从来不在任何命令里绑定C-h键，所以C-c C-d C-h跟C-c C-d h做的事情是不一样的。这是因为Emacs内建的默认情况是，输入一个前缀，然后按C-h，会显示处所有以该前缀开始的键绑定。所以C-c C-d C-h命令实际上会显示出所有的文档命令。这个特性太有用了所以我们不会替换它！

“你是故意破坏Emacs超级牛逼的在线帮助机制吗？上帝都会震怒的！”

此建议十分有用。Emacs的在线帮助机制是你最快捷、最完整和最新的关于键绑定的信息来源。它们是你的朋友：

** 3.2 求值命令

这些命令每一个都以不同的方式来对一个Common Lisp表达式求值。一般来说它们模仿Emacs Lisp的求值命令。默认情况下它们会在显示区显示出结果，但是一个前缀参数会让结果插入到当前缓冲区中。

- C-x C-e 或 M-x M-x slime-eval-last-expression

  对光标前的表达式求值并且将结果显示到显示区

- C-M-x 或 M-x slime-eval-defun
  
  对当前toplevel的形式进行求值并将结果打印到显示区。“C-M-x”会特别对待“defvar”。正常来讲，如果定义的变量已经有一个值了，“defvar”表达式不会做任何事情。但是“C-M-x”命令无条件的将“defvar”表达式里定义的值初始化并赋予指定的值。这个特性十分便于调试Lisp程序。

如果带数字参数地执行C-M-x或者C-x C-e，它会将结果插入到当前缓冲区，而不是将其打印到显示区。

- C-c : 或 M-x slime-interactive-eval

  从迷你缓冲区读取一个表达式并求值

- C-c C-r 或 M-x slime-eval-region

  对区域进行求值

- C-c C-p 或 M-x slime-pprint-eval-last-expression

  对光标前的表达式进行求值并将结果漂亮地打印在一个新的缓冲区里

- C-c E 或 M-x slime-edit-value

  在一个叫做“Edit <form>”的新缓冲区里编辑一个可以setf的形式的值。这个值会被插入一个临时缓冲区以便编辑，然后用C-c C-c命令来提交设置于Lisp中。

- C-x M-e 或 M-x slime-eval-last-expression-display-output
  
  对光标前的表达式求值并将结果打印在显示缓冲区里。如果表达式会写一些内容到输出流的话这会很有用。

- C-c C-u 或 M-x slime-undefine-function

  用fmakunbound来取消当前光标处函数的定义。

** 3.3 编译命令

Slime有许多很好的命令来编译函数、文件和包。好的地方在于，很多Lisp编译器生成的提示和警告会被拦截，然后直接注释给Lisp源文件缓冲区里相应的表达式。（试一试看会发生什么。）

- C-c C-c 或 M-x slime-compile-defun

  编译光标处的top-level形式。被选择的区域会闪一下以给出回应，表明是哪一部分被选择了。若给了一个（正的）前缀参数的时候，形式会以最小调试设置来编译。若是一个负的前缀参数，编译速度会被优化。区域里的代码在编译之后将要被执行，总的来说，此命令将该区域写入一个文件，编译该文件，然后加载结果代码。

- C-c C-k 或 M-x slime-compile-and-load-file
  
  编译和加载当前缓冲区的源文件。如果编译步骤失败了，那么文件不会被加载。编译是否失败并不总是那么容易判断的：某些情况下你可能会在加载阶段进入调试器。

- C-c M-k 或 M-x slime-compile-file

  编译（但不加载）当前缓冲区的源文件。

- C-c C-l 或 M-x slime-load-file

  加载Lisp文件。此命令用到了Common Lisp的LOAD函数。

- M-x slime-compile-region

  编译选中的区域。

Slime通过在源代码的形式下加下划线来表示有提示信息。可以通过将鼠标置于文本处或者下面这些选择命令来阅读带有提示信息的编译器消息。

- M-n 或 M-x slime-next-note

  将光标移到下一个编译器消息处并显示消息。

- M-p 或 M-x slime-previous-note

  将光标移到上一个编译器消息处并显示消息。

- C-c M-c 或 M-x slime-remove-notes

  删除缓冲区里的所有提示信息。

- C-x ‘ 或 M-x next-error

  访问下一个错误消息。实际上这不是一个Slime命令，Slime会创建一个隐藏的缓冲区，然后大部分的编译模式的命令（见info “emacs”文件的“Compilation Mode”节点）都会类似批处理编译器一样地编译Lisp。

** 3.4 补全命令

补全命令的作用是根据光标处已有的东西来补全一个符号或者形式。典型的补全假设一个确定的前缀，给出的选择也只是可能发生的分支。模糊补全会做更多的尝试。

- M-TAB 或 M-x slime-complete-symbol

  补全光标处的符号。注意，Slime里有三种模式的补全；默认的模式跟正常的Emacs补全类似（见6.1 slime-complete-symbol-function）

** 3.5 查找定义（“Meta-Point”命令）

Slime提供了熟悉的M-.命令。对于广泛函数来讲此命令会找出所有的方法，而在某些系统上它会做一切其它事情（例如根据DEFSTRUCT定义来追踪结构访问器）。

- M-. 或 M-x slime-edit-definition
  
  跳至光标处符号的定义处

- M-, 或 M-* 或 M-x slime-pop-find-definition-stack

  回到M-.命令执行的光标处。如果M-.被执行了多次，那么此命令会多重地回溯。

- C-x 4 . 或 M-x slime-edit-definition-other-window

  类似slime-edit-definition，但是会跳到另一个窗口来编辑其定义。

- C-x 5 . 或 M-x slime-edit-definition-other-frame
  
  类似slime-edit-definition，但是会跳到另一个框架来编辑其定义。

- M-x slime-edit-definition-with-etags

  使用ETAGES的表来寻找当前光标处的定义。

** 3.6 文档命令

Slime的在线文档命令效仿了Emacs的例子。这些命令都以C-c C-d为前缀，并且允许更改其键绑定或者取消更改（见 3.1.4 键绑定）

* 三、使用Slime模式


Slime的所有命令都通过slime-mode提供。它是一个与Emacs的lisp-mode配合使用的minor-mode。本章描述slime-mode及其相关事项。


** 3.1 用户界面须知


要方便地使用Slime，了解一些“全局的”用户界面特性是十分重要的。这一部分描述了最为重要的原则。


*** 3.1.1 临时缓冲区


某些Slime命令会创建临时缓冲区来显示结果。虽然这些缓冲区有它们自己的为了特定目的而使用的major-mode，但某些特定的约定是通用的。


可以通过按q键来关闭临时缓冲区。此操作会关闭缓冲区并且回复缓冲区显示之前的窗口配置。临时缓冲区也可以通过一般的命令例如kill-buffer来关闭，这样的话之前的窗口配置就不会被恢复。


按RET键被认为是“做最明显的有用的事情”。例如，在apropos缓冲区此操作会打印出当前光标处的符号的详细描述，而在XREF缓冲区此操作会显示当前光标处的索引的源代码。这样的行为是效仿Emacs的显示相关内容、补全结果等的缓冲区。


含有Lisp符号的临时缓冲区会使用slime-mode来补充它自己的特定的模式。这样就可以使用一般的Slime命令，例如描述符号、查找函数定义等等。


对这些“描述性的”缓冲区的初始聚焦由变量slime-description-autofocus确定。如果它是nil（默认的），这些描述性缓冲区不会自动聚焦，反之则会。


*** 3.1.2 *inferior-lisp*缓冲区


Slime在内部使用comint包来启动Lisp进程。这会产生一些用户可见的结果，有些是好的，另一些则不是。为了避免产生疑惑，理解其交互特性是很有用的。


*inferior-lisp*缓冲区包含有Lisp进程自己的top-level。这个与Lisp的直接连接对错误排查很有用，并且使用inferior-slime-mode可以达到某种程度上的Slime集成。许多人选择加载更好的集成模块SLIME REPL包（见8.2 REPL）而无视*inferior-lisp*缓冲区。（见8.1 加载扩展包 获得更多关于启动REPL的信息。）


*** 3.1.3 多线程


如果Lisp支持多线程，对于每个请求Slime会生成一个新的线程，例如，C-x C-e会创建一个新线程来对表达式求值。但是对于从REPL来的请求则是一个例外：所有在REPL缓冲区里输入的命令都会在一个专用的REPL线程里求值。


多线程和特殊变量会导致一些复杂性。非全局的特殊绑定是在本地线程里的，也就是说，在一个线程里改变一个由let绑定的特殊变量的值不会影响到其它线程里相同名字的变量的值。这增加了改变新线程的打印和读取行为的困难程度。变量swank:*default-worker-thread-bindings*就是为了应付这种情况的：不需要改变一个变量的全局的值，而是增加swank:*default-worker-thread-bindings*的绑定，例如，使用下面的代码，新的线程会默认将浮点值读取为double。


#+BEGIN_SRC emacs-lisp
(push '(*read-default-float-format* . double-float)
      swank:*default-worker-thread-bindings*)
#+END_SRC
